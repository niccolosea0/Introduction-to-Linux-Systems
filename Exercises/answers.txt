1. ვთქვათ შელში იმყოფებით /home/user/Documents დირექტორიაში.
გადადით /usr/share/common-licenses დირექტორიაში. გამოიყენეთ
როგორც აბსოლუტური გზა, ასევე ფარდობითი.
----------------------------------------------------------------------|
	აბსოლუტური: cd /usr/share/common-licenses		      |	
	ფარდობითი: cd ../../../usr/share/common-licenses    	      |	
----------------------------------------------------------------------|

2. ვთქვათ იმყოფებით /usr/local/bin დირექტორიაში. გადადით
/usr/share/common-licenses დირექტორიაში. გამოიყენეთ როგორც
აბსოლუტური გზა, ასევე ფარდობითი.
----------------------------------------------------------------------|
	აბსოლუტური: cd /usr/share/common-licenses		      |
	ფარდობითი: cd ../../share/common-licenses		      |	
----------------------------------------------------------------------|
3. ვთქვათ იმყოფებით რომელიმე დირექტორიაში. გადადით თქვენს პირად
დირექტორიაში როგორც აბსოლუტური, ასევე ფარდობითი გზით.
-------------------------------------------------------------------------------|
	აბსოლუტური: cd						       
	ფარდობითი (ვთქვათ ვიმყოფებით /usr/share): cd ../../home/user/         									       |
-------------------------------------------------------------------------------|

4. შექმენით ფაილები შემდეგი დასახელებით: „name“, „name surname“,
„name\surname“, „'name "surname'“, „'".“, „'/\"“. ოპერაცია
შეასრულეთ შელში ერთი ბრძანებით!
---------------------------------------------------------------------------------------------------|
	შევქმნათ "name": mkdir name								   |	
	შევქმნათ "name surname": mkdir 'name surname'						   |		
	შევქმნათ "name\surname": mkdir 'name\surname'						   |	
	შევქმნათ „'".“: mkdir \'\".								   |	
	შევქმნათ „'/\"“: არ შეიქმნება, (/) არ შეიძლება გამოყენებულ იქმნეს ფაილის შექმნისას!!!	   |
---------------------------------------------------------------------------------------------------|

5. HTML დასახელების დირექტორიაში შექმენით 1000 ცალი tml გაფართოების
ფაილი (გაფართოება უნდა იყოს დიდი, პატარა და შერეული ასოებით მოცემული).
ოპერაცია შეასრულეთ შელში ერთი ბრძანებით!
---------------------------------------------------------------------------------------------------|
	mkdir HTML										   |
	touch {1..999}.html									   |
---------------------------------------------------------------------------------------------------|

6. შექმენით ფაილები „name1“, „name2“ და „name3“ დასახელებით
როგორც „txt“ გაფართოებით, ასევე მის გარეშე. ოპერაცია შეასრულეთ
შელში ერთი ბრძანებით!
---------------------------------------------------------------------------------------------------|
	touch name{1..3}{,.txt}									   |											   	
---------------------------------------------------------------------------------------------------|

7. შექმენით ფაილები „name1“, „name2“ და „name3“ დასახელებით
როგორც „txt“ გაფართოებით (გაფართოება მიუთითეთ დიდი და პატარა
ასო-ნიშნების ყველა შესაძლო კომბინაციით: txt, tXt, txT…) ასევე მის
გარეშე. ოპერაცია შეასრულეთ შელში ერთი ბრძანებით!
---------------------------------------------------------------------------------------------------|
	touch name{1..3}{,.{t,T}{x,X}{t,T}}
---------------------------------------------------------------------------------------------------|

8. შექმენით ფაილები „name100“, „name101“ … „name2023“ დასახელებით
როგორც „txt“ გაფართოებით (გაფართოება მიუთითეთ დიდი და პატარა
ასო-ნიშნების ყველა შესაძლო კომბინაციით: txt, tXt, txT…) ასევე მის
გარეშე. ოპერაცია შეასრულეთ შელში ერთი ბრძანებით!
---------------------------------------------------------------------------------------------------|
	touch name{100..2023}{,.{t,T}{x,X}{t,T}}						   
---------------------------------------------------------------------------------------------------|

9. შექმენით სამ ასო-ნიშნიანი დასახელების დირექტორიები, რომლის
პირველი ასო-ნიშანი იქნება A-დან Z-ის ჩათვლით, მეორე a-დან z-ის
ჩათვლით, ხოლო მესამე ციფრი. ოპერაცია შეასრულეთ შელში ერთი
ბრძანებით!
---------------------------------------------------------------------------------------------------|
	mkdir {A..Z}{a..z}{0..9}
---------------------------------------------------------------------------------------------------|

10. test დირექტორიაში შექმენით სამ ასო-ნიშნიანი ყველა შესაძლო
დასახელების მქონე ფაილი ", \, $, @ და ' ასო-ნიშნებით.
---------------------------------------------------------------------------------------------------|
	mkdir test
	touch test/{\",\\,\$,\@,\'}{\",\\,\$,\@,\'}{\",\\,\$,\@,\'}
---------------------------------------------------------------------------------------------------|

11. შექმენით ყველა შესაძლო ორ ასო-ნიშნიანი დასახელების დირექტორიები,
რომელთა დასახელებებიც თვლის თექვსმეტობითი სისტემის სიმბოლოების
ყველა კომბინაციას წარმოადგენს. ოპერაცია შეასრულეთ შელში ერთი
ბრძანებით!
---------------------------------------------------------------------------------------------------|
	mkdir {0-9}{A..E}
---------------------------------------------------------------------------------------------------|

12. შექმენით სამ ასო-ნიშნიანი ყველა შესაძლო დასახელების დირექტორია
ციფრებით. მათში სათითაოდ შექმენით ყველა შესაძლო ერთი, ორი, სამი და
ოთხ სიმბოლოიანი დასახელების ფაილები A, B და C ასო-ნიშნებით.
ოპერაცია შეასრულეთ შელში ერთი ბრძანებით!
---------------------------------------------------------------------------------------------------|
	mkdir {0..9}{0..9}{0..9}	
	touch {0..9}{0..9}{0..9}/{A..C}{,{A..C},{A..C}{A..C},{A..C}{A..C}{A..C}}
---------------------------------------------------------------------------------------------------|

შემდეგ კი ეკრანზე გამოიტანეთ შემდეგი ფაილები:
ა) 01234̅̅̅̅̅̅̅̅̅ ∀56789̅̅̅̅̅̅̅̅̅ /∀C̅B1
---------------------------------------------------------------------------------------------------|
	ls [!0-4]?[!5-9]/?[^C]B
---------------------------------------------------------------------------------------------------|
ბ) ყველა 2 ასო-ნიშნიანი დასახელების ფაილი, რომელიც
მდებარეობს იმ დირექტორიებში, რომლის დასახელებაშიც არ შედის
სიმბოლო „5“
---------------------------------------------------------------------------------------------------|
	ls [!5][!5][!5]/??
---------------------------------------------------------------------------------------------------|
გ) ყველა 1 და 3 ასო-ნიშნიანი დასახელების ფაილი, სადაც არ
შევა სიმბოლო „B“ და რომლებიც მდებარეობს დირექტორიებში,
რომლის დასახელებაშიც შედის მხოლოდ სიმბოლოები „1“, „3“ და „9“
---------------------------------------------------------------------------------------------------|
	ls [139][139][139]/{[!B],[!B][!B][!B]}
---------------------------------------------------------------------------------------------------|

13. შექმენით სამ ასო-ნიშნიანი ყველა შესაძლო დასახელების დირექტორია "
და ' ასო-ნიშნებით.
---------------------------------------------------------------------------------------------------|
	mkdir {\',\"}{\',\"}{\',\"}
---------------------------------------------------------------------------------------------------|

14. დაუშვათ გაქვთ ბევრი jpg, bmp და png გაფართოების ფაილი
“Photos/” დირექტორიაში. ამოარჩიეთ მათგან ის jpg და png ფაილები,
რომელთა დასახელებაშიც ფიგურირებს ერთი ციფრი მაინც და რომლის
პირველი ასო-ნიშანიც D-დან P-მდეა. ოპერაცია შეასრულეთ შელში ერთი
ბრძანებით!
---------------------------------------------------------------------------------------------------|
	ls ~/Pictures/{D..P}*{0..9}*.{jpg,png}
---------------------------------------------------------------------------------------------------|

15. დაუშვათ გაქვთ ბევრი jpg, bmp და png გაფართოების ფაილი
“Photos/” დირექტორიაში. ამოარჩიეთ მათგან ის jpg და png ფაილები
(გაფართოება შესაძლებელია დიდი, პატარა ან შერეული ასოებით იყოს
მოცემული!), რომელთა დასახელებაშიც ფიგურირებს ერთი ციფრი მაინც
და რომლის პირველი ასო-ნიშანიც D-დან P-მდეა. ოპერაცია შეასრულეთ
შელში ერთი ბრძანებით!
---------------------------------------------------------------------------------------------------|
	ls ~/Pictures/[D-P]*[0-9]*.{{j,J}{p,P}{g,G},{p,P}{n,N}{g,G}}
---------------------------------------------------------------------------------------------------|

16. დაუშვათ გაქვთ ბევრი flv, vob და ogg გაფართოების ვიდეო ფაილი “Videos/”
დირექტორიაში. ამოარჩიეთ მათგან ის flv და ogg ფაილები (გაფართოება
შესაძლებელია დიდი, პატარა ან შერეული ასოებით იყოს მოცემული!), რომელთა
დასახელებაშიც ფიგურირებს ერთი ციფრი მაინც და რომლის ბოლო ასო-ნიშანიც
K-დან Q-მდეა. ოპერაცია შეასრულეთ შელში ერთი ბრძანებით!
---------------------------------------------------------------------------------------------------|
	ls ~/Videos/*[0-9]*[K-Q].{{f,F}{l,L}{v,V},{o,O}{g,G}{g,G}}
---------------------------------------------------------------------------------------------------|

17. დაუშვათ გაქვთ ბევრი pdf და txt გაფართოების ფაილი “Documents/”
დირექტორიაში. ამოარჩიეთ მათგან ის pdf ფაილები, რომლის დასახელებაც 7
ასო-ნიშნიანია (გაფართოების გარეშე) და ის txt ფაილები, რომელთა
დასახელებაშიც ფიგურირებს 2 ციფრი მაინც და რომლის პირველი ასო-ნიშანიც C-
დან R-მდეა. ოპერაცია შეასრულეთ შელში ერთი ბრძანებით!
---------------------------------------------------------------------------------------------------|
	ls ~/Documents/???????.pdf ~/Documents/[C-R]*[0-9]*[0-9]*.txt
---------------------------------------------------------------------------------------------------|

18. მე-15, მე-16 და მე-17 დავალებების პირობის გათვალისწინებით გადააკოპირეთ
TEST დირექტორიაში ხუთასონიშნიანი ყველა სურათის, ვიდეოს და დოკუმენტის
ფაილი, რომელიც ციფრზე მთავრდება. ოპერაცია შეასრულეთ შელში ერთი
ბრძანებით!
1 X̅ ნიშნავს X-ის უარყოფას, ხოლო ∀ ნებისმიერი სიმბოლოა'
----------------------------------------------------------------------------------------------------------------------------------------|
	cp ~/{Documents,Videos,Photos}/????[0-9].{{j,J}{p,P}{g,G},{p,P}{n,N}{g,G},{f,F}{l,L}{v,V},{o,O}{g,G}{g,G},pdf,txt} ~/Test
----------------------------------------------------------------------------------------------------------------------------------------|

19. მე-15 და მე-16 დავალებების პირობის გათვალისწინებით გადააკოპირეთ TEST
დირექტორიაში ხუთასონიშნიანი სურათის ფაილებისა და შვიდასონიშნიანი
ვიდეოს ფაილების გარდა სხვა სურათები და ვიდეოფაილები. ოპერაცია
შეასრულეთ შელში ერთი ბრძანებით!
---------------------------------------------------------------------------------------------------------------------------------------------------|
	cp {~/Pictures/!(?????).{[jJ][pP][gG],[bB][mM][pP],[pP][nN][gG]},~/Videos/!(???????).{[fF][lL][vV],[vV][oO][bB],[oO][gG][gG]}} ~/Test/
---------------------------------------------------------------------------------------------------------------------------------------------------|

20. გამოიტანეთ ეკრანზე ორსიმბოლოიანი ფაილების (იგულისხმება ყველა ტიპის
ფაილი) გარდა ყველა დანარჩენი. ოპერაცია შეასრულეთ შელში ერთი ბრძანებით!
---------------------------------------------------------------------------------------------------|	
	ls !(??)
	ls ? ???*
---------------------------------------------------------------------------------------------------|

21. მე-15, მე-16 და მე-17 დავალებების პირობის გათვალისწინებით გადაიტანეთ TEST
დირექტორიაში სურათის ყველა ის ფაილები, რომელთა დასახელებაშიც არ შედის
„a“ ასო-ნიშანი, ვიდეოს ყველა ის ფაილები, რომელთა დასახელებაშიც არ შედის
„b“ ასო-ნიშანი და დოკუმენტის ყველა ის ფაილები, რომელთა დასახელებაშიც არ
შედის „c“ ასო-ნიშანი. ოპერაცია შეასრულეთ შელში ერთი ბრძანებით!
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
mv {~/Pictures/!(*a*).{[jJ][pP][gG],[bB][mM][pP],[pP][nN][gG]},~/Videos/!(*b*).{[fF][lL][vV],[vV][oO][bB],[oO][gG][gG]},~/Documents/!(*c*).{[pP][dD][fF],[tT][xX][tT]}} ~/Test
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|

22. მე-15, მე-16 და მე-17 დავალებების პირობის გათვალისწინებით გადაიტანეთ TEST
დირექტორიაში სურათის ყველა ის ფაილები, რომელთა დასახელებაშიც არ შედის
ლათინური პატარა ასო-ნიშნები (გაფართოების გარდა), ვიდეოს ყველა ის
ფაილები, რომელთა დასახელებაშიც არ შედის ციფრები და დოკუმენტის ყველა
ის ფაილები, რომელთა დასახელებაშიც არ შედის ლათინური დიდი ასო-ნიშნები
(გაფართოების გარდა). ოპერაცია შეასრულეთ შელში ერთი ბრძანებით!
---------------------------------------------------------------------------------------------------|
mv {~/Pictures/[A-Z]*[A-Z]*[A-Z].{[jJ][pP][gG],[bB][mM][pP],[pP][nN][gG]},~/Videos/[0-9]*[0-9]*[0-9].{[fF][lL][vV],[vV][oO][bB],[oO][gG][gG]},~/Documents/[a-z]*[a-z]*[a-z].{[pP][dD][fF],[tT][xX][tT]}} ~/Test
---------------------------------------------------------------------------------------------------|

23. აღწერეთ ხესებრი სტრუქტურით შელის შემდეგი ბრძანება:
ls /usr/{local/{bin,lib},lib/{gimp/?.?*,emacs/[0-9]*.[1-9]}}
---------------------------------------------------------------------------------------------------|
1. /usr/local/bin
2. /usr/local/lib
3. /usr/lib/gimp/?.?*
4. /usr/libl/emacs/[0-9]*.[1-9]
---------------------------------------------------------------------------------------------------|

24. აღწერეთ
ხესებრი სტრუქტურით შელის
შემდეგი
ბრძანება:
ls
/usr/{share/{common-licenses/{,L}GPL-?,doc/HOWTO},{local/{bin,lib},lib/{gimp/?.?*,emacs/[0-9]*.[1-9]}}}
---------------------------------------------------------------------------------------------------|
1. /usr/share/common-licenses/GPL-?
2. /usr/share/common-licenses/LGPL-?
3. /usr/share/doc/HOWTO
4. /usr/local/bin
5. /usr/local/lib
6. /usr/lib/gimp/?.?*
7. /usr/lib/emacs/[0-9]*.[1-9]
---------------------------------------------------------------------------------------------------|

25. ვთქვათ გაქვთ ფაილი toto, რომლის შიგთავსშიც ჩაწერილია სხვა
ფაილის სახელი. გამოიტანეთ ამ უკანასკნელის შიგთავსი ეკრანზე.
ოპერაცია შეასრულეთ შელში ერთი ბრძანებით 2 მილით ან/და მილის
გარეშე.
---------------------------------------------------------------------------------------------------|
	cat $(cat toto)
---------------------------------------------------------------------------------------------------|

26. ვთქვათ გაქვთ ფაილი toto, რომლის შიგთავსშიც ჩაწერილია სხვა
ფაილის სახელი. ამავდროულად მასში კიდევ სხვა ფაილის სახელი fil
ჩაწერილი. გამოიტანეთ ამ უკანასკნელის ზომა ეკრანზე. ოპერაცია
შეასრულეთ შელში ერთი ბრძანებით მილით ან/და მილის გარეშე.
---------------------------------------------------------------------------------------------------|
	ls -l $(cat $(cat toto))
---------------------------------------------------------------------------------------------------|

27. ვთქვათ გაქვთ foo დასახელების დირექტორიაში bar ფაილი, რომლშიც
შიგთავსად ჩაწერილია სხვა ფაილის სრული გზა. გამოიტანეთ ამ უკანასკნელის
ზომა ეკრანზე. ოპერაცია შეასრულეთ შელში ერთი ბრძანებით მილით ან/და
მილის გარეშე.
---------------------------------------------------------------------------------------------------|
	cat ~/Test/foo/bar | wc -c
---------------------------------------------------------------------------------------------------|

28. შექმენით ფაილი დასახელებით toto თუ ის არ არსებობს.
---------------------------------------------------------------------------------------------------|
	ls toto 2>/dev/null || touch toto
---------------------------------------------------------------------------------------------------|

29. შექმენით ფაილი დასახელებით  toto, თუ titi დასახელების ფაილი არ
არსებობს. ეკრანზე შეცდომის შეტყობინება არ გამოიტანოთ.
---------------------------------------------------------------------------------------------------|
	ls titi 2>/dev/null || touch toto
---------------------------------------------------------------------------------------------------|

30. შექმენით ფაილი დასახელებით toto თუ file დასახელების ფაილი
არსებობს, თუ არადა შექმენით ფაილი titi. ეკრანზე შეტყობინება არ
გამოიტანოთ.
---------------------------------------------------------------------------------------------------|
	ls file 1>/dev/null 2>/dev/null && touch toto || touch titi
---------------------------------------------------------------------------------------------------|

31. გაუშვით „ls -l“ ბრძანება ერთ ტერმინალზე,ხოლო მისი შედეგი გამოიტანეთ მეორე ტერმინალზე
---------------------------------------------------------------------------------------------------|
	გავიგოთ რომელ ტერმინალზე ვართ ჯერ: tty (გვიჩვენებს ამ ტერმინალის ნომერს)
	შემდეგ ტერმინალზეც გავუშვათ იგივე ბრძანება, რათა გავიგოთ შემდეგი ტერმინალის ნომერი
	შედეგი იქნება რაღაც მსგავსი: ამჟამინდელი ტერმინალი /dev/pts/0, 
				         შემდეგი ტერმინალი /dev/pts/1
	
	ბრძანება: ls -l > /dev/pts/1
---------------------------------------------------------------------------------------------------|

32. გაუშვით toto ფაილის შიგთავსის ნახვის ბრძანება ერთ ტერმინალზე,ხოლო მისი შედეგი გამოიტანეთ მეორე ტერმინალზე.
---------------------------------------------------------------------------------------------------|
	cat toto > /dev/pts/1
---------------------------------------------------------------------------------------------------|

33. აკოპირეთ toto ფაილის შიგთავსის titi-ში. თუ toto ფაილი არ არსებობს არ გამოიტანოთ ეკრანზე შეცდომის შეტყობინება
---------------------------------------------------------------------------------------------------|
	cp toto titi 2>/dev/null
---------------------------------------------------------------------------------------------------|

34. დაამატეთ /etc დირექტორიაში არსებული ყველა conf გაფართოების
ფაილების სია თქვენი პირადი დირექტორიის list_conf.txt ფაილში. ოპერაცია შეასრულეთ შელში ერთი ბრძანებით!
---------------------------------------------------------------------------------------------------|
	ls /etc/*.conf > ~/list_conf.txt
---------------------------------------------------------------------------------------------------|

35. დაამატეთ /etc დირექტორიაში არსებული ყველა conf გაფართოების
ფაილების სია თქვენი პირადი დირექტორიის list_conf.txt ფაილში და ამავდროულად ეს სია ეკრანზეც გამოიტანეთ
ოპერაცია შეასრულეთ შელში ერთი ბრძანებით!
---------------------------------------------------------------------------------------------------|
	ls /etc/*.conf | tee ~/list_conf.txt
---------------------------------------------------------------------------------------------------|

36. დაამატეთ პირად დირექტორიაში არსებული ყველა txt გაფართოების ფაილების სია /tmp/list.txt ფაილში და ამავდროულად ეს სია ეკრანზეც გამოიტანეთ.
ოპერაცია შეასრულეთ შელში ერთი ბრძანებით!
---------------------------------------------------------------------------------------------------|
	ls ~/*.txt | tee /tmp/list.txt
---------------------------------------------------------------------------------------------------|

37. /etc დირექტორიის ყველა ფაილის სახელი გადაამისამართეთ ფაილ liste_etc.txt-ში და
კონფიგურაციის ყველა ფაილი კი liste_etc_conf.txt-ში. ოპერაცია შეასრულეთ შელში ერთი ბრძანებით!
---------------------------------------------------------------------------------------------------|
	ls /etc/!(*.*) 1> liste_etc.txt ; ls /etc/*.conf 1> liste_etc_conf.txt
---------------------------------------------------------------------------------------------------|

38. ვთქვათ გაქვთ 3 ფაილი (n1.txt, n2.txt, n3.txt), რომლებშიც ჩაწერილია შემთხვევითი რიცხვები. 
გამოითვალეთ შემდეგი არითმეტიკული გამოსახულება ამ ფაილებში მითითებული რიცხვებით: (n1+(n2*n3))/n2
---------------------------------------------------------------------------------------------------|
	echo "($(cat n2.txt) + $(cat n1.txt)) / $(cat n3.txt)" | bc
---------------------------------------------------------------------------------------------------|

39. გამოიტანეთ π-ს მნიშვნელობა მძიმის შემდეგ 1000 ციფრის სიზუსტით.
---------------------------------------------------------------------------------------------------|
	echo "scale=1000; 4*a(1)" | bc -l
---------------------------------------------------------------------------------------------------|

40. გამოიტანეთ 12345 ხარისხად 6789 მნიშვნელობა.
---------------------------------------------------------------------------------------------------|
	echo "12345^6789" | bc
---------------------------------------------------------------------------------------------------|

41. შექმენით ცვლადი File, რომლისაც მნიშვნელობად გარკვეულ არითმეტიკულ გამოსახულებას მიანიჭებთ (მაგალითად 12+3-5). შექმენით
ფაილი იმ დასახელებით, რასაც ამ არითმეტიკული გამოსახულების გამოთვლის შედეგად მიიღებთ. ოპერაცია შეასრულეთ შელში ერთი ბრძანებით!
---------------------------------------------------------------------------------------------------|
	touch $(File='15+20-5' && echo $File | bc)	
---------------------------------------------------------------------------------------------------|

42. შექმენით ცვლადი File, რომლისაც მნიშვნელობად გარკვეულ არითმეტიკულ გამოსახულებას მიანიჭებთ (მაგალითად 12+3-5). გახსენით
ფაილი დასარედაქტირებლად იმ დასახელებით, რაც ამ არითმეტიკული გამოსახულების გამოთვლის შედეგად მიიღებთ, შეიტანეთ რამდენიმე ხაზი
და აკოპირეთ ეს შიგთავსი სხვა ფაილში, რომლის დასახელებას „1“ -ით მეტია მიღებულ არითმეტიკულ შედეგზე. ოპერაცია შეასრულეთ შელში
ერთი ბრძანებით!
-----------------------------------------------------------------------------------------------------------------------|
	File="15+15-5" && fileName=$"echo $File | bc && touch $fileName && tee $fileName > $(echo $fileName-1 | bc)"	
-----------------------------------------------------------------------------------------------------------------------|

43. გააფერადეთ შელის მოსაწვევი (Shell Prompt string).
-----------------------------------------------------------------------------------------------------------------------|
	PS1="\[\e[36m\]\u@\h \[\e[34m\]\w \[\e[0m\]\$ "
-----------------------------------------------------------------------------------------------------------------------|

44. შეცვალეთ შელის მოსაწვევი შემდეგნაირად: „I’m in …(მიმდინარე დირექტორიის სახელი), Now it is …(მიმდინარე დრო), this is …(ბრძანების ნომერი)th command“
-----------------------------------------------------------------------------------------------------------------------|
	PS1="I'm in \w, Now it is \t, this is \#th command "	
-----------------------------------------------------------------------------------------------------------------------|

45. შექმენით შემდეგი ტიპის ფერადი shell მოწვევა. « My processes number is – N $ ».
-----------------------------------------------------------------------------------------------------------------------|
	PS1="\[\e[31m\]My processes number is - \[\e[32m\]$(ps -u $USER --no-headers | wc -l)\[\e[33m\] $ \[\e[0m\]"
-----------------------------------------------------------------------------------------------------------------------|

46. რას შეასრულებს შელის შემდეგი ბრძანება: $ cat <ls> cat
-----------------------------------------------------------------------------------------------------------------------|
	3) „ls“ ფაილის შიგთავსს გადააწერს „cat“ დასახელების ფაილს
-----------------------------------------------------------------------------------------------------------------------|

47. რას შეასრულებს შელის შემდეგი ბრძანება: $ cat <cat> ls
-----------------------------------------------------------------------------------------------------------------------|
	8) „cat“ ფაილის შიგთავსს გადააწერს „ls“ დასახელების ფაილს
-----------------------------------------------------------------------------------------------------------------------|

48. რას შეასრულებს შელის შემდეგი ბრძანება: 
	$ cat <<ls>> sort
	> pwd
	> mkdir
	> ls
-----------------------------------------------------------------------------------------------------------------------|
	3) „sort“ ფაილის შიგთავსს ბოლოში დაამატებს კლავიატურიდან შეტანილ პირველ 2 ხაზს.	
-----------------------------------------------------------------------------------------------------------------------|

49. რას შეასრულებს შელის შემდეგი ბრძანება: $ wc file.txt | tee wc
-----------------------------------------------------------------------------------------------------------------------|
	1) დაითვლის file.txt ფაილში ახალ ხაზზე გადასვლის, სიტყვისა და ბაიტების რაოდენობას და აკოპირებს მას wc ფაილში
-----------------------------------------------------------------------------------------------------------------------|

50. რას შეასრულებს შელის შემდეგი ბრძანება: $ wc tee | tee wc
-----------------------------------------------------------------------------------------------------------------------|
	1) დაითვლის tee ფაილში ახალ ხაზზე გადასვლის, სიტყვისა და ბაიტების რაოდენობას და აკოპირებს მას wc ფაილში
-----------------------------------------------------------------------------------------------------------------------|

51. განსხვავდება თუ არა ამ ორი ბრძანების შედეგი:
		$ command 2>&1 >file
		$ command >file 2>&1
-----------------------------------------------------------------------------------------------------------------------|
	1) პირველი ბრძანება command-ის სტანდარტულ გამოსასვლელს გადაიტანს file-ში, ხოლო შეცდომას ეკრანზე,
	მეორე კი command-ის სტანდარტულ და შეცდომების გამოსასვლელს გადაიტანს file-ში.	
-----------------------------------------------------------------------------------------------------------------------|

52. გახსენით ტერმინალი და გაუშვით შემდები ბრძანებები:
		$ VAR1="გამარჯობა"
		$ VAR2="საქართველო"
		$ export VAR1
		$ bash
		$ echo $VAR1 $VAR2
		$ exit
		$ echo $VAR1 $VAR2
	„echo“ ბრძანება ერთნაირ შედეგს გამოიტანს ორივე შემთხვევაში? თუ
	კი რატომ? თუ არა რატომ?
-----------------------------------------------------------------------------------------------------------------------|
	არ გამოიტანას ერთნაირ შედეგს, იმიტომ რომ VAR1 არის გარემო ცვლადი და როდესაც ბრძანება bash-ით შვილ shell-ს ვქნით
	იქ მხოლოდ გარემო ცვლადი იქნება თვალსაჩინო (VAR1) ლოკალური ან shell ცვლადი (VAR2) არ იქნება თვალსაჩინო შვილ shell-ში
	როდესაც exit-ს ვაკეთებთ, ანუ შვილ shell-ს ვთიშავთ, ვუბრუნდებით მშობელ shell-ს და აქ ორივე ცვლადი
	თვალსაჩინოა და შედეგიც განსხვავდება.
	1. გამარჯობა
	2. გამარჯობა საქართველო
-----------------------------------------------------------------------------------------------------------------------|

53. გახსენით ტერმინალი და გაუშვით შემდები ბრძანებები:
		$ VAR1="გამარჯობა"
		$ VAR2="საქართველო"
		$ export VAR1
		$ echo $VAR1 $VAR2
		$ unset VAR1
		$ echo $VAR1 $VAR2
	„echo“ ბრძანება ერთნაირ შედეგს გამოიტანს ორივე შემთხვევაში? თუ
	კი რატომ? თუ არა რატომ?
-----------------------------------------------------------------------------------------------------------------------|
	არ გამოიტანს ერთნაირ შედეგს, რადგან პირველი გამოტანის შემდეგ, VAR1 ცვლადს ვუკეთებთ unset-ს, ე.ი VAR1 ცვლადი
	აღარ არსებობს, შემდეგ გამოტანზე კი დაიბეჭდება მხოლოდ VAR2 ცვლადის მნიშვნელობა
	1. გამარჯობა საქართველო
	2. საქართველო
-----------------------------------------------------------------------------------------------------------------------|

54. გახსენით ტერმინალი და გაუშვით შემდები ბრძანებები:
		$ VAR1="გამარჯობა"
		$ VAR2="საქართველო"
		$ export VAR1 VAR2
		$ echo $VAR1 $VAR2
		$ export -n VAR1
		$ bash
		$ echo $VAR1 $VAR2
		$ exit
		$ echo $VAR1 $VAR2
	„echo“ ბრძანება ერთნაირ შედეგს გამოიტანს სამივე შემთხვევაში? თუ
	კი რატომ? თუ არა რატომ?
-----------------------------------------------------------------------------------------------------------------------|
	1. გამარჯობა საქართველო
	2. საქართველო
	3. გამარჯობა საქართველო
	მიზეზი რატომაც მეორე ჯერზე განსხვავებული შედეგი მივიღეთ არის ის, რომ export -n VAR1 ბრძანებით ცვლადი აღარ არის გარემო ცვლადი,
	არამედ ჩვეულებრივი shell ცვლადი, შესაბამისად როდესაც შვილ shell-ში გადავდივართ იქ VAR1 არ ჩანს.
-----------------------------------------------------------------------------------------------------------------------|

55. გახსენით ტერმინალი და შექმენით ცვლადები შემდები მნიშვნელობებით:
		$ VAR1="გამარჯობა"
		$ VAR2="საქართველო"
	რა შედეგი გამოვა ეკრანზე თითოეული ბრძანების შესრულებისას:
		1. echo $VAR1$VAR2
		2. echo $VAR1VAR2
		3. echo ${VAR1}${VAR2}
		4. echo $VAR13$VAR24
		5. echo ${VAR1}${VAR2}4
		6. echo $VAR1${{VAR2}
		7. echo $VAR1{VAR2}
-----------------------------------------------------------------------------------------------------------------------|
	1. გამარჯობასაქართველო
	2. (ცარიელი ხაზი, რადგან ცვლადი სახელად: $VAR1VAR2 არ არსებობს)
	3. გამარჯობასაქართველო
	4. (ცარიელი ხაზი, რადგან მსგავსი ცვლადები არ არსებობენ)
	5. გამარჯობასაქართველო4
	6. არასწორი სინტაწსია!!!
	7. გამარჯობა{VAR2}
-----------------------------------------------------------------------------------------------------------------------|

56. აკოპირეთ  /bin დირექტორიიდან $HOME/bin-ში ls ბრძანება და გაუშვით.
-----------------------------------------------------------------------------------------------------------------------|
	cp /bin/ls $HOME/bin/ && $HOME/bin/ls
-----------------------------------------------------------------------------------------------------------------------|

57. გადაანაცვლეთ cp და mv ბრძანებების ეფექტები (ყურადღება მიაქციეთ იმას, რომ თქვენ არ გაქვთ ადმინისტრატორის უფლებები!)
--------------------------------------------------------------------------------------------------------------------------------|
	cp /bin/mv ~/ && mv ~/mv ~/bin/cp -- mv ბრძანება როგორც cp
	cp /bin/cp ~/ && mv ~/cp ~/bin/mv -- cp ბრძანება როგორც mv
--------------------------------------------------------------------------------------------------------------------------------|

58. დააცარიელეთ $HOME/tmp დირექტორია. წაშალეთ დამალული ფაილებიც. (ყურადღება მიაქციეთ იმას, რომ დირექტორიაში არ უნდა შეეხოთ . და .. დასახელების ქვედირექტორიებს).
--------------------------------------------------------------------------------------------------------------------------------|
	rm -rf $HOME/tmp/* $HOME/tmp/.[!.]*
--------------------------------------------------------------------------------------------------------------------------------|

59. რომელი ბრძანება დააცარიელებს $HOME/tmpfile ფაილს და გაანულებს მის ზომას (მრავალი პასუხი):

	1) cat /dev/null > $HOME/tmpfile 
	2) cp /dev/null > $HOME/tmpfile
	3) echo "" > $HOME/tmpfile
	4) echo > $HOME/tmpfile
	5) echo -n > $HOME/tmpfile
	6) true > $HOME/tmpfile
	7) > $HOME/tmpfile
	8) truncate -s0
--------------------------------------------------------------------------------------------------------------------------------|
	1) კი - რადგან dev/null არის ცარიელი წყარო, შესაბამისად cat ცარიელი წყარო ბეჭდავს არაფერს და ეს არაფერი გადადის ფაილში
	2) არა cp-ს სტანდარტული გამოსასვლელი არ გამოაქვს შესაბამისად >-ს ვერ გამოვიყენებთ
	3) არა - newline იბეჭდება
	4) არა მაინც newline იბეჭდება
	5) კი, newline არ გამოაქვს, ანუ არაფერი არ გამოაქვს და ეს არაფერი გადადის ფაილში
	6) კი, არაფერი იბეჭდება ბრძანება true-თი
	7) კი, არაფერი გადადის ფაილში
	8) კი პირდაპირ ეუბნება ბირთვს რომ ფაილის ზომა გახდეს 0
--------------------------------------------------------------------------------------------------------------------------------|

60. ვთქვათ თქვენს სისტემაში გაქვთ ორი ბირთვის ფაილი: /boot/vmlinuz-3.16.0-4-amd64 და /boot/vmlinuz-4.9.0-4-amd64. დაიმახსოვრეთ
მათ შორის განსხვავება vmlinuz3.16-4.9 ფაილში და ერთი ბირთვის დაკარგვის შემთხვევაში აღადგინეთ ის.
--------------------------------------------------------------------------------------------------------------------------------|
	diff /boot/vmlinuz-3.16.0-4-amd64 /boot/vmlinuz-4.9.0-4-amd64 > vmlinuz3.16-4.9
	დავუშვთ დაგვეკარგა /boot/vmlinuz-3.16.0-4-amd64 ფაილი
	patch /boot/vmlinuz-4.9.0-4-amd64 < vmlinuz3.16-4.9 // ამ ბრძანებით მივაბავთ განსხვავებას მეორე ფაილს
	 და აღდგება ჩვენი დაკარგული ფაილის
--------------------------------------------------------------------------------------------------------------------------------|

61. ბრძანება « cmp », რომლის დანიშნულებაა ორი სხვადასხვა ფაილის ერთმანეთთან შედარება, განხორციელდება წარმატებით
    ან წარუმატებლად. წარმოიდგინეთ ორივე შესაძლებლობა და მოიყვანეთ ამის მტკიცებულება.
--------------------------------------------------------------------------------------------------------------------------------|
	წარმატებით სრულდება მაშინ როდესაც, ორი ფაილში ჩაწერლი ინფორმაცია იდენტურია (ადარებს ბაიტ-ბაიტზე), ამ დროს ეკრანზე არ იბეჭდება
	არაფერი მაგრამ აბრუნებს exit_status 0-ს, ხოლო წარუმატებლად მაშინ, როდესაც განსხვავდება შიგთავსი ამ დროს ეკრანზე
	იბეჭდება თუ რომელ ბაიტზე განსხახვდება ფაილები და ბრუნდება exit_status 1.

	exit_status ეკრანზე არ იბეჭდება თავისით, მისი შემოწმება შეგვიძლი cmp ბრძანების გაშვების შემდეგ. > $? - ამ ბრძანებით
--------------------------------------------------------------------------------------------------------------------------------|

62. დაყავით toto ფაილი ისე, რომ დანაყოფი ფაილები შეიცავდნენ toto ფაილის 10-10 ხაზს. დანაყოფების სახელის სუფიქსი იყოს toto_
--------------------------------------------------------------------------------------------------------------------------------|
	split -l10 toto toto_	
--------------------------------------------------------------------------------------------------------------------------------|

63. toto ფაილი დაყავით N თანაბარ ნაწილად პრეფიქსით: toto_part და ციფრული სუფიქსებით.
--------------------------------------------------------------------------------------------------------------------------------|
	split -n10 -d toto toto_part
--------------------------------------------------------------------------------------------------------------------------------|

64. toto ფაილი დაყავით ისე, რომ თითოეული დანაყოფის ფაილი შეიცავდეს toto ფაილის 5 სტრიქონს.
--------------------------------------------------------------------------------------------------------------------------------|
	split -l10 toto 
--------------------------------------------------------------------------------------------------------------------------------|

65. აიღეთ bmp გაფართოების (ან დაუმუშავებელი სურათის ფაილი) და დაყავით N ნაწილად. ეკრანზე გამოიტანეთ:

	სურათის მხოლოდ პირველი 2/3 ნაწილი
	სურათის მხოლოდ პირველი 1/10 ნაწილი
	წაანაცვლეთ დანაყოფები bmp გაფართოების ფაილში (მე-2 დანაყოფი მე-3 ში გადაიტანეთ, მე-3 მე-4-ში, 
	ა.შ. და ბოლო  მე-2-ში. პირველ ნაწილს არ შეეხოთ!). ნახეთ და შედეგს მიიღებთ.
--------------------------------------------------------------------------------------------------------------------------------|
	split -n -d image.bmp part_
	cat part_00 part_01 > first_2_3.bmp // პირველი 2/3 ნაწილი
	
	split -n10 -d image.bmp ten_
	cat ten_00 > first_1_10.bmp // პირველი 1/10 ნაწილი	
	
	// დანაყოფების წანაცვლება
	split -n4 -d image.bmp image_part_
	cat image_part_00 image_part_03 image_part_01 image_part_02 > result.bmp

--------------------------------------------------------------------------------------------------------------------------------|

66. 6 მბ ზომის mp3 ფაილი დაყავით ისე, რომ მისი ნაწილები ტრანსპორტირებადი იყოს დისკეტების მეშვეობით (ზომა - 1.44 MB).
    გადაწერის შემდეგ, ააწყეთ საწყისი ფაილი.
--------------------------------------------------------------------------------------------------------------------------------|
	split -b1440k -d sample.mp3 sample_	// დავყოთ 1.44mb=1440k ზომად
	
	cat sample_* > song.mp3		// ავაყწოთ

	md5sum sample.mp3 song.mp3	// შევამოწმოთ, შიგთავსი ხომ ნამდვილად ერთი და იგივეა
	
--------------------------------------------------------------------------------------------------------------------------------|

67. მოძებნეთ ყველა html ფაილი თქვენს პირად დირექტორიაში და შეინახეთ მათი დასახელებები fichier.html.
--------------------------------------------------------------------------------------------------------------------------------|
	find ~ -name ".html" | sed 's|^[./].*/||' > ./fichier.html
--------------------------------------------------------------------------------------------------------------------------------|

68.თქვენი პირადი დირექტორიიდან უკანა პლანზე გაუშვით ყველა html ფორმატის ფაილის ძიება ისე რომ ისინი 
   გადაამისამართოთ ფაილ $HOME/fichier.html-ში.
--------------------------------------------------------------------------------------------------------------------------------|
	find "$HOME" -name "*.html" | sed "s|^[./].*/||" > "$HOME/fichier.html" &
--------------------------------------------------------------------------------------------------------------------------------|

77. მოძებნეთ ყველა ფაილი, რომელთაც აქვთ მხოლოდ და მხოლოდ წვდომის შემდეგი უფლებები: წაკითხვა მფლობელისთვის, 
    ისევე როგორც ჯგუფისთვის და წაკითხვა/მოდიფიკაცია სხვა მომხმარებლებისთვის.
--------------------------------------------------------------------------------------------------------------------------------|
	find ~ -type f -perm 446	
--------------------------------------------------------------------------------------------------------------------------------|

78. მოძებნეთ ყველა ფაილი, რომელთაც აქვთ ჩამოთვლილთაგან ერთ-ერთი უფლება მაინც: წაკითხვა მფლობელისთვის, ისევე როგორც ჯგუფისთვის,
    და წაკითხვა/მოდიფიკაცია სხვა მომხმარებლებისთვის.
--------------------------------------------------------------------------------------------------------------------------------|
	find ~ -type f -perm /446
--------------------------------------------------------------------------------------------------------------------------------|

79. მოძებნეთ ყველა ფაილი, რომელთაც აქვთ მხოლოდ და მხოლოდ შემდეგი უფლებები: წაკითხვა მესაკუთრეებისთვის, ისევე როგორც ჯგუფისთვის,
    წაკითხვა/მოდიფიკაცია სხვა მომხმარებლებისთვის და გადაადგილეთ ისინი დირექტორიაში: $HOME/Problems.
--------------------------------------------------------------------------------------------------------------------------------|
	mv $(find "$HOME" -type f -perm 446) "$HOME/Problems"
--------------------------------------------------------------------------------------------------------------------------------|

80. მოძებნეთ ყველა ფაილი, რომელთაც აქვთ შემდეგი უფლებები: წაკითხვა ყველასთვის, წერა მესაკუთრისთვის და
    ჯგუფისთვის ან სხვა მომხმარებლისთვის.
--------------------------------------------------------------------------------------------------------------------------------|
	find ~ -type f -perm -u=rw,g=r,o=r \( -perm -g=w -o -perm -o=w \)	
--------------------------------------------------------------------------------------------------------------------------------|

81. მოძებნეთ ყველა დირექტორია sticky bit წვდომის უფლებით.
--------------------------------------------------------------------------------------------------------------------------------|
	find / -type d -perm -1000
--------------------------------------------------------------------------------------------------------------------------------|

82. მოძებნეთ ყველა ფაილი თქვენს პერსონალურ დირექტორიაში, რომელთაც წვდომის არანაირი უფლება არ აქვთ.
--------------------------------------------------------------------------------------------------------------------------------|
	find "$HOME" -type f -perm 0000
--------------------------------------------------------------------------------------------------------------------------------|

83. მოძებნეთ ყველა ფაილი თქვენს პერსონალურ დირექტორიაში, რომელთაც აქვთ აქტიური SUID bit.
--------------------------------------------------------------------------------------------------------------------------------|
	find ~ -type f -perm -4000	
--------------------------------------------------------------------------------------------------------------------------------|

84. მოძებნეთ ყველა ჩვეულებრივი ფაილი თქვენს პერსონალურ დირექტორიაში, რომელთაც აქვთ უფლება: 777 და გარდაქმენით 644.
--------------------------------------------------------------------------------------------------------------------------------|
	chmod 644 $(find ~ -type f -perm 777)
--------------------------------------------------------------------------------------------------------------------------------|

91. აჩვენეთ მიმდინარე მომხმარებლის კუთვნილი პროცესები.
--------------------------------------------------------------------------------------------------------------------------------|
	ps -u $USER
--------------------------------------------------------------------------------------------------------------------------------|

92. იპოვეთ syslog პროცესის PID.
--------------------------------------------------------------------------------------------------------------------------------|
	ps aux | grep rsyslogd | tr -s ' ' | cut -d ' ' -f2
--------------------------------------------------------------------------------------------------------------------------------|

93. შეადარეთ ერთმანეთს თქვენი და root-ის მიერ გაშვებული პროცესების რაოდენობა
--------------------------------------------------------------------------------------------------------------------------------|
	ps -u $USER --no-headers | wc -l
	ps -u root --no-headers | wc -l
--------------------------------------------------------------------------------------------------------------------------------|

94. პროცესორის გამოყენებადობის მიხედვით გაფილტრეთ ყველა პროცესი.
--------------------------------------------------------------------------------------------------------------------------------|
	1. top -o %CPU
	2. ps aux --sort=-%cpu | head
--------------------------------------------------------------------------------------------------------------------------------|

95. მეხსიერების გამოყენებადობის მიხედვით გაფილტრეთ პროცესები.
--------------------------------------------------------------------------------------------------------------------------------|
	1. top -o %MEM
	2. ps aux --sort=-%mem | head
--------------------------------------------------------------------------------------------------------------------------------|

96. რეალურ დროში მეხსიერებიდან გაფილტრეთ პირველი 10 მუშა პროცესი ისე, რომ განახლების პერიოდი იყოს 1 წამი.
--------------------------------------------------------------------------------------------------------------------------------|
	top -o %MEM -d 1 | head -n 17	
--------------------------------------------------------------------------------------------------------------------------------|

97. ps -aux" განსხვავებულ შედეგს იძლება ვიდრე "ps aux" ?
--------------------------------------------------------------------------------------------------------------------------------|
	დიახ, ps -aux გამოაქვს ყველა პროცესი რომელიც ეკუთვნის მოხმარებელ x-ს, თუ მომხარებელი x არ არსებობს
	მაშინ ინტერპრეტერი აღიქვამს ამ ბრძანებას, როგორც ps aux	
--------------------------------------------------------------------------------------------------------------------------------|

98. აჩვენეთ პროცესების სია მომხმარებლის მიერ განსაზღვრულ ფორმატში კერძოდ - PID ნომერი, მფლობელის სახელი და ბრძანების სახელი.
--------------------------------------------------------------------------------------------------------------------------------|
	ps -o pid,uname,comm
--------------------------------------------------------------------------------------------------------------------------------|

99. გამოიტანეთ იმ პროცესების სია, რომელიც შეიცავს რომელიმე კონკრეტრულ გამოსახულებას სახელში (მაგალითად chrome ).
--------------------------------------------------------------------------------------------------------------------------------|
	ps aux | grep zen
--------------------------------------------------------------------------------------------------------------------------------|

100. დახურეთ gedit -ის ყველა პროცესი ერთბაშად.
--------------------------------------------------------------------------------------------------------------------------------|
	killall gedit	
	kill $(pgrep gedit)
--------------------------------------------------------------------------------------------------------------------------------|

101. დახურეთ ყველა პროცესი ერთბაშად, რომლის სახელიც იწყება „chr“-ით.
--------------------------------------------------------------------------------------------------------------------------------|
	killall '^chr'
	kill $(pgrep '^chr')
--------------------------------------------------------------------------------------------------------------------------------|
